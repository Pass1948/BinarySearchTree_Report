namespace BinarySearchTree_Report
{
    internal class Program
    {
        /******************************************************
		 * 트리 (Tree)
		 * 
		 * 계층적인 자료를 나타내는데 자주 사용되는 자료구조
		 * 부모노드가 0개 이상의 자식노드들을 가질 수 있음
		 * 한 노드에서 출발하여 다시 자기 자신의 노드로 돌아오는 순환구조를 가질 수 없음
		 * 순환구조가 없으면서 부모가 여러 자식들을 가질수 있는 구조가 트리구조임(순환구조일경우 그래프라고함)
		 * 
		 ******************************************************/

        /******************************************************
		 * 이진탐색트리 (BinarySearchTree)
		 * 
		 * 이진속성과 탐색속성을 적용한 트리
		 * 이진탐색을 통한 탐색영역을 절반으로 줄여가며 탐색 가능
		 * 이진 : 부모노드는 최대 2개의 자식노드들을 가질 수 있음
		 * 탐색 : 자신의 노드보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치( 1 - 5 - 8)
		 * 탐색에 있어 이분법적인 탐색이 가능한 트리임
		 * 큰값은 탐색하면 작은값은 고려안하는 이분법적인 계산이 들어가서 (반대도 동일) 효율성이 좋다
		 * 
		 ******************************************************/

        // <이진탐색트리의 시간복잡도>
        // 접근			탐색			삽입			삭제
        // O(log n)		O(log n)	O(log n)	O(log n)

        /* <이진탐색트리의 주의점>
         * 이진탐색트리의 노드들이 한쪽 자식으로만 추가되는 불균형 발생 가능
         * 시간복잡도상에는 정말 좋은 효율성을 보여주지만 이진탐색트리상 한쪽에 불균형이 일어나면
         * 효율성이 모두 O(N)만큼의 비효율적인 구조를 갖게된다
         * 이 경우 탐색영역이 절반으로 줄여지지 않기 때문에 시간복잡도 증가
         * 이러한 현상을 막기 위해 자가균형기능을 추가한 트리의 사용이 일반적
         * 대표적인 방식으로 Red-Black Tree, AVL Tree 등이 있음
         * 노드의 균형을 맞추기 위해서 우회전, 좌회전을 사용하는 경우가 있음
         * 
         * Red-Black Tree : 우회전과 좌회전을 통해서 균형을 맞춤
         * 5가지 규칙을 갖고있음
         * 1. 모든 노드는 빨간색 아니면 검은색이다
         * 2. 루트 노드는 검은색이다
         * 3. 잎 노드는 검은색이다
         * 4. 빨간 노드의 자식들은 모두 검은색이다 하지만 검은색 노드의 자식이 빨간색일 필요는 없다
         * 5. 루트 노드에서 모든 잎 노드 사이에 있는 검은색 노드의 수는 모두 동일하다
         * 색에 따라 불균형을 판단하고 좌회전 또는 우회전을 통해 균형을 이루게 한다
        */

        /*
         * <트리기반 자료구조의 순회>
         * 1. 전위순회 :  노드(본인), 왼쪽, 오른쪽
         * 2. 중위순회 :  왼쪽, 노드(본인), 오른쪽   <- 이진탐색트리의 순회 : 오름차순 정렬
         * 3. 후위순회 :  왼쪽, 오른쪽, 노드(본인)
         * 
         * 
         * 
         * 
         * 
         */
        static void Main(string[] args)
        {
           
        }
    }
}